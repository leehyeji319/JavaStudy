# 1장 - 협력하는 객체들의 공동체
---
### 서문 
> 클래스가 아니라 객체를 바라보는것
객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 존재로 바라보는 것
협력에 참여하는 객체들에게 얼마나 적절한 역할과 책음을 부여하느냐
앞 선 개념들을 프로그래밍 언어에 담아내는 기술을 익히는 것.

---

>* 객체지향의 목표는 실세계를 모방하는 것이 아니다. 오히려 새로운 세계를 창조하는 것이다.
* 객체를 스스로 생각하고 스스로 결정하는 현실 세계의 생명체에 비유하는 것은 상태와 행위를 **'캡슐화(encapsulation)'**하는 소프트웨어 객체의 **'자율성(autonomous)'**을 설명하는 데 효과적이다.
* 현실 세계의 사람들이 암묵적인 약속과 명시적인 계약을 기반으로 협력하며 목표를 달성해 나가는 과정은 **'메세지(message)'**를 주고받으며 공동의 목표를 달성하기 위해 **'협력(collaboration)'**하는 객체들의 관계를 설명하는 데 적합하다.
* 실세계의 사물을 기반으로 소프트웨어 객체를 식별하고 구현까지 이어간다는 개념은 객체지향 설계의 핵심 사상인 **'연결완전성(seamlessness)'**을 설명하는 데 적합한 틀을 제공한다.

> 캡슐화, 자율성, 메세지, 협력, 완전연결성


## 협력하는 사람들 - 커피 공화국의 아침 
* 역할: 손님, 캐시어, 바리스타
* 책임: 커피 주문, 주문 받기, 커피 제조
* 협력: 커피를 주문하는 과정 

### 요청과 응답으로 구성된 협력
_**요청 : ```손님``` ->(커피를 주문한다) ```캐시어``` ->(커피를 제조하라) ```바리스타```**_
_**응답 : ```손님``` (커피 완성)<- ```캐시어``` (커피 완성)<- ```바리스타```**_
* 요청과 응답을 통해 다른 사람과 협력(collaboration)한다. 협력의 성공은 특정한 역할을 맡은 각 개인이 얼마나 요청을 성실히 이행하는가에 달려 있다.

### 역할과 책임
**역할(role)**이라는 단어는 의미적으로 **책임(responsibility)**이라는 개념을 내포한다.
특정한 역할은 특정한 책임을 암시한다. 협력에 참여하며 특정한 역할을 수행하는 사람들은 역할에 적합한 책임을 수행하게 된다.역할과 책임은 협력이 원활하게 진행되는 데 필요한 핵심적인 구성 요소.
* 여러 사람이 동일한 역할을 수행할 수 있다.
* 역할은 대체 가능성(subsitutable)을 의미한다.
* 책임을 수행하는 방법은 자율적으로 선택할 수 있다(다형성 polymorphism).
* 한 사람이 동시에 여러 역할을 수행할 수 있다.

### 역할, 책임, 협력
* 기능을 구현하기 위해 협력하는 객체들
    * *사람 -> 객체*
    * *요청 -> 메세지*
    * *요청 처리 방법 -> 메서드*

* 역할과 책임을 수행하며 협력하는 객체들
    * 협력의 핵심은 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다는 것.
    * 시스템은 역할과 책임을 수행하는 객체로 분할된다.
    * 시스템의 기능은 객체간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현된다.
    
* 적절한 객체에게 적절한 책임을 할당하는 것
* 객체의 역할 특징 
  * 여러 객체가 동일한 역할을 수행할 수 있다.
  * 역할은 대체 가능성을 의미한다.
  * 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
  * 하나의 객체가 동시에 여러 역할을 수행할 수 있다. 
* 역할은 유연하고 재사용 가능한 협력 관계를 구축하는 데 중요한 설계 요소이다.
* 대체 가능한 역할과 책임은 다형성과도 깊이 연관돼있다.

### 협력 속에 사는 객체
* 객체지향 애플리케이션의 윤곽을 결정하는 것은 역할, 책임, 협력이지만 실제로 협력에 참여하는 주체는 객체다.
* 객체는 다른 객체와의 협력을 통해 기능을 구현하게 된다. 
* 협력의 품질을 결정하는 것은 객체의 품질이다.

협력 공동체의 일원으로서 객체는 다음과 같은 두 가지 덕목을 갖춰야 하며, 두 덕목 사이에서 균형을 유지해야한다.
* 첫째, 객체는 충분히 ```'협력적'```이어야한다. (객체는 다른 객체의 명령에 복종하는 것이 아니라 요청에 응답할 뿐이다.)
* 둘째, 객체가 충분히 ```'자율적'```이어야 한다. (자기 스스로의 원칙에 따라 어떤 일을 하거나 자기 스스로를 통제하여 절제하는 것)
> 객체지향 설계의 묘미는 다른 객체와 조화롭게 협력할 수 있을 만큼 충분히 개방적인 동시에 협력에 참여하는 방법을 스스로 결정할 수 있을 만큼 충분히 자율적인 객체들의 공통체를 설계하는 것에 있다.

* 상태와 행동을 함께 지닌 자율적인 객체 (객체가 협력에 참여하기 위해 어떤 행동을 해야 한다면 그 행동을 하는 데 필요한 상태도 함께 지니고 있어야한다.)
  * 객체는 다른 객체가 무엇(what)을 수행하는지는 알 수 있지만, '어떻게(how)' 수행하는지에 대해서는 알 수 없다.
  * 객체는 상태와 행위를 하나의 단위로 묶는 자율적인 존재다.
  * 과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분한다. 반면에, *객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 함께 묶어 놓음으로써 객체의 자율성을 보장한다.*

* 협력과 메세지
  * 객체지향에서는 오직 한 가지 의사소통수단만이 존재. 이를 ```메시지```라고 한다.
  * 객체지향 세계에서 협력은 메시지를 전송하는 객체와 메시지를 수신하는 객체 사이의 관계로 구성된다.
    * 이때 메시지를 전송하는 객체를 ```송신자(sender)```라고 부르고 메시지를 수신하는 객체를 ```수신자(receiver)```라고 부른다.

* 메서드와 자율성
  * 객체가 수신된 메시지를 처리하는 방법을 ```메서드(method)```라고 부른다.
  * *메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 점*은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나이다.
  * 메세지와 메서드의 분리는 객체의 협력에 참여하는 객체들 간의 자율성을 증진시킨다. 
  * 외부의 요청이 무엇인지를 표현하는 메세지와 요청을 처리하기 위한 구체적인 방법인 *메서드를 분리*하는 것은 객체의 자율성을 높이는 핵심 메커니즘이다. 이것은 ```캡슐화(encapsulation)```라는 개념과도 깊이 관련되어있다. 
  
### 객체지향의 본질
* 객체지향이란 시스템을 상호작용하는 **자율적인 객체들의 공동체**로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.
* 자율적인 객체란 **상태**와 **행위**를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
* 객체는 시스템의 행위를 구현하기 위해 다른 객체와 **협력**한다. 각 객체는 협력 내에서 정해진 **역할**을 수행하며 역할은 관련된 **책임**의 집합이다.
* 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, **메시지**를 수신한 객체는 메시지를 처리하는 데 적합한 **메서드**를 자율적으로 선택한다.

#### 객체를 지향하라
* 지나치게 클래스를 강조하는 프로그래밍 언어적인 관점은 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합시킨다.
* 휼륭한 객체지향이 되기 위해서는 코드를 담는 클래스의 관점에서 _메시지를 주고받는 객체의 관점으로 사고를 전환_하는 것이다.
* 어떤 클래스가 필요한가가 아니라 *어떤 객체들이 어떤 메시지를 주고받으며 협력하는가*다.
* 중요한 것은 클래스들의 정적인 관계가 아니라 *메시지를 주고받는 객체들의 동적인 관계*다.
* 클래스의 구조와 메서드가 아니라 *객체의 역할, 책임, 협력에 집중*하라.